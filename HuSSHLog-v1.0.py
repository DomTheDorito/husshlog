# *********************************
# *        HuSSHLog v1.0          *
# *      By:  DomTheDorito        * 
# *                               *
# *    Please give atribution!    *
# *********************************


#!/usr/bin/env python3
import curses, csv, os, sys
from datetime import datetime, timezone

FIELDS = [
    "My Call",
    "Callsign",
    "Date (YYYYMMDD)",
    "Time (HHMM UTC)",
    "Band",
    "Mode",
    "RST Sent",
    "RST Recv",
    "Name",
    "QTH",
    "Notes"
]

# Alias for labels
ADIF_MAP = {
    "My Call": "STATION_CALLSIGN",
    "Callsign": "CALL",
    "Date (YYYYMMDD)": "QSO_DATE",
    "Time (HHMM UTC)": "TIME_ON",
    "Band": "BAND",
    "Mode": "MODE",
    "RST Sent": "RST_SENT",
    "RST Recv": "RST_RCVD",
    "Name": "NAME",
    "QTH": "QTH",
    "Notes": "COMMENT"
}

# Color Palettes
PALETTES = [
    {"name": "Cyan",   "bg": curses.COLOR_BLACK, "label": curses.COLOR_CYAN,   "highlight": curses.COLOR_YELLOW, "input": curses.COLOR_WHITE, "log": curses.COLOR_GREEN,  "footer": curses.COLOR_WHITE, "reverse_highlight": False},
    {"name": "Amber",  "bg": curses.COLOR_BLACK, "label": curses.COLOR_YELLOW, "highlight": curses.COLOR_WHITE,  "input": curses.COLOR_WHITE, "log": curses.COLOR_YELLOW,"footer": curses.COLOR_YELLOW,"reverse_highlight": False},
    {"name": "Red",    "bg": curses.COLOR_BLACK, "label": curses.COLOR_RED,    "highlight": curses.COLOR_WHITE, "input": curses.COLOR_WHITE, "log": curses.COLOR_RED,   "footer": curses.COLOR_RED, "reverse_highlight": False},
    {"name": "Grey",   "bg": curses.COLOR_WHITE, "label": curses.COLOR_BLACK,  "highlight": curses.COLOR_BLACK, "input": curses.COLOR_BLACK, "log": curses.COLOR_BLACK, "footer": curses.COLOR_BLACK, "reverse_highlight": True},
    {"name": "BIOS-Amber","bg": 238, "label": 214, "highlight": 214, "input": 214, "log": 214, "footer": 214, "reverse_highlight": True},
    {"name": "BIOS-Green","bg": 238, "label": 46,  "highlight": 46,  "input": 46,  "log": 46,  "footer": 46,  "reverse_highlight": True}
]

def safe_addstr(win, y, x, text, attr=0):
    try:
        h, w = win.getmaxyx()
        if 0 <= y < h and 0 <= x < w:
            win.addstr(y, x, text[: w - x - 1], attr)
    except curses.error:
        pass

# Make sure log exists, if not, generate one
def ensure_csv(logfile):
    if not os.path.exists(logfile):
        with open(logfile, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(FIELDS)

def add_qso(logfile, qso_data):
    with open(logfile, "a", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(qso_data)
		
# Export to ADIV
def csv_to_adif(csvfile, adiffile):
    with open(csvfile, newline="") as f:
        reader = csv.DictReader(f)
        with open(adiffile, "w") as out:
            out.write("Generated by HuSSHLog\n<EOH>\n")
            for row in reader:
                for key, val in row.items():
                    if val:
                        out.write(f"<{key.upper()}:{len(val)}>{val} ")
                out.write("<EOR>\n")

# Fetch UTC date and time
def get_utc_now():
    now = datetime.now(timezone.utc)
    return now.strftime("%Y%m%d"), now.strftime("%H%M")

def read_last_qsos(logfile, count=10):
    if not os.path.exists(logfile):
        return []
    with open(logfile, newline="") as f:
        reader = list(csv.reader(f))
        return reader[-count:] if len(reader) > 1 else []

def curses_main(stdscr, logfile):
    curses.curs_set(1)
    stdscr.keypad(True)
    curses.start_color()
    if curses.can_change_color():
        curses.use_default_colors()

    current_palette = 0

    def init_palette(pidx):
        p = PALETTES[pidx]
        curses.init_pair(1, p["label"], p["bg"])
        curses.init_pair(2, p["highlight"], p["bg"])
        curses.init_pair(3, p["input"], p["bg"])
        curses.init_pair(4, p["log"], p["bg"])
        curses.init_pair(5, p["footer"], p["bg"])
        stdscr.bkgd(" ", curses.color_pair(1))
        stdscr.clear()

    init_palette(current_palette)

    my_call = ""
    current_field = 0

    def reset_fields():
        d, t = get_utc_now()
        data = [""] * len(FIELDS)
        data[0] = my_call
        data[2] = d
        data[3] = t
        return data

    inputs = reset_fields()

    while True:
        stdscr.erase()
        height, width = stdscr.getmaxyx()
        if height < 24 or width < 80:
            safe_addstr(stdscr, 0, 0, "Terminal too small! Resize to at least 80x24.")
            stdscr.refresh()
            key = stdscr.getch()
            if key in (27, curses.KEY_F10):
                break
            continue

        p = PALETTES[current_palette]

        # Header
        stdscr.attron(curses.color_pair(2) | curses.A_BOLD)
        safe_addstr(stdscr, 0, 0, " " * width)
        header = f"HuSSHLog | {os.path.basename(logfile)} | UTC {datetime.now().strftime('%H:%M:%S')} | Palette: {p['name']}"
        safe_addstr(stdscr, 0, 2, header[: width - 4])
        stdscr.attroff(curses.color_pair(2) | curses.A_BOLD)

        # Form
        start_y = 2
        form_width = min(60, width - 4)
        safe_addstr(stdscr, start_y - 1, 1, "+" + "-"*(form_width) + "+", curses.color_pair(2))
        for i, field in enumerate(FIELDS):
            label = f"{field:<18}: "
            attr = curses.color_pair(2) if i == current_field else curses.color_pair(1)
            if p.get("reverse_highlight") and i == current_field:
                attr |= curses.A_REVERSE
            safe_addstr(stdscr, start_y + i, 2, label, attr)
            safe_addstr(stdscr, start_y + i, 22, inputs[i][:form_width-22], curses.color_pair(3))
        safe_addstr(stdscr, start_y + len(FIELDS), 1, "+" + "-"*(form_width) + "+", curses.color_pair(2))

        # Divider & logs
        log_start = start_y + len(FIELDS) + 2
        safe_addstr(stdscr, log_start, 0, "-" * width, curses.color_pair(2))
        log_data = read_last_qsos(logfile, height - log_start - 3)
        if len(log_data) > 1:
            log_lines = log_data[1:]
            for idx, row in enumerate(log_lines):
                line = f"{row[1]:<10} {row[2]} {row[3]} {row[4]:<5} {row[5]:<5} {row[6]:<3}/{row[7]:<3} {row[8]:<10} {row[9]:<10}"
                safe_addstr(stdscr, log_start + 1 + idx, 2, line[: width - 4], curses.color_pair(4))

        # Footer
        stdscr.attron(curses.color_pair(5))
        footer = "TAB: Next | ENTER: Save | F2: Export ADIF | F3: Change Palette | ESC/F10: Quit"
        safe_addstr(stdscr, height - 1, 0, " " * width)
        safe_addstr(stdscr, height - 1, 2, footer[: width - 4])
        stdscr.attroff(curses.color_pair(5))

        stdscr.refresh()
        key = stdscr.getch()

        # Navigation & input
        if key in (9, getattr(curses, "KEY_TAB", 9)):
            current_field = (current_field + 1) % len(FIELDS)
        elif key in (353, getattr(curses, "KEY_BTAB", 353)):
            current_field = (current_field - 1) % len(FIELDS)
        elif key in (10, 13):
            if inputs[1].strip():
                add_qso(logfile, inputs)
                my_call = inputs[0]
                inputs = reset_fields()
        elif key == curses.KEY_F2:
            adiffile = logfile.replace(".csv", ".adi")
            csv_to_adif(logfile, adiffile)
        elif key == curses.KEY_F3:
            current_palette = (current_palette + 1) % len(PALETTES)
            init_palette(current_palette)
        elif key in (27, curses.KEY_F10):
            break
        elif 32 <= key <= 126:
            inputs[current_field] += chr(key)
        elif key in (curses.KEY_BACKSPACE, 127):
            inputs[current_field] = inputs[current_field][:-1]

def main():
    if len(sys.argv) < 2:
        print("Usage: HuSSHLog.py <logbook_name>")
        sys.exit(1)

    logfile = sys.argv[1]
    if not logfile.endswith(".csv"):
        logfile += ".csv"

    ensure_csv(logfile)
    curses.wrapper(curses_main, logfile)

if __name__ == "__main__":
    main()
